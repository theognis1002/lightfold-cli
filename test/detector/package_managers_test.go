package detector_test

import (
	"testing"
)

// Package Manager Detection Tests

func TestYarnBerryDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		packageManager    string
	}{
		{
			name: "Yarn Berry with Next.js",
			files: map[string]string{
				".yarnrc.yml": `nodeLinker: node-modules
yarnPath: .yarn/releases/yarn-3.6.0.cjs`,
				"package.json": `{
  "name": "yarn-berry-app",
  "packageManager": "yarn@3.6.0",
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0"
  }
}`,
				"next.config.js": "module.exports = {}",
				"pages/index.js": "export default function Home() { return <div>Home</div> }",
			},
			expectedFramework: "Next.js",
			packageManager:    "yarn-berry",
		},
		{
			name: "Yarn Berry with React",
			files: map[string]string{
				".yarnrc.yml": "nodeLinker: pnp",
				"package.json": `{
  "name": "react-app",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}`,
				"src/index.js": "import React from 'react';",
			},
			expectedFramework: "Unknown",
			packageManager:    "yarn-berry",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			// Verify package manager detection
			if pm, ok := detection.Meta["package_manager"]; ok {
				if pm != tt.packageManager {
					t.Errorf("Expected package manager %s, got %s", tt.packageManager, pm)
				}
			} else if tt.expectedFramework != "Unknown" {
				t.Error("Expected package_manager in meta, but it was not found")
			}
		})
	}
}

func TestPDMDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		packageManager    string
	}{
		{
			name: "PDM with FastAPI",
			files: map[string]string{
				"pdm.lock": `# This file is @generated by PDM.
# It is not intended for manual editing.

[[package]]
name = "fastapi"
version = "0.104.0"`,
				"pyproject.toml": `[project]
name = "pdm-fastapi-app"
version = "0.1.0"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn>=0.24.0"
]

[build-system]
requires = ["pdm-backend"]
build-backend = "pdm.backend"`,
				"main.py": `from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}`,
			},
			expectedFramework: "FastAPI",
			packageManager:    "pdm",
		},
		{
			name: "PDM with Django",
			files: map[string]string{
				"pdm.lock": `# This file is @generated by PDM.

[[package]]
name = "django"
version = "4.2.0"`,
				"pyproject.toml": `[project]
name = "pdm-django-app"
dependencies = ["django>=4.2.0"]`,
				"manage.py": `#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "myproject.settings")
    from django.core.management import execute_from_command_line
    execute_from_command_line(sys.argv)`,
			},
			expectedFramework: "Django",
			packageManager:    "pdm",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			// Verify package manager detection
			if pm, ok := detection.Meta["package_manager"]; ok {
				if pm != tt.packageManager {
					t.Errorf("Expected package manager %s, got %s", tt.packageManager, pm)
				}
			}

			// Verify PDM install command in build plan
			if len(detection.BuildPlan) > 0 {
				if detection.BuildPlan[0] != "pdm install --prod" {
					t.Errorf("Expected PDM install command, got %s", detection.BuildPlan[0])
				}
			}
		})
	}
}

