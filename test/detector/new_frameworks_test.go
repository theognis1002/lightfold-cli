package detector_test

import (
	"testing"
)

// Remix Detection Tests
func TestRemixDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		packageManager    string
		minConfidence     float64
	}{
		{
			name: "Remix with config and package.json",
			files: map[string]string{
				"remix.config.js": `/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  ignoredRouteFiles: ["**/.*"],
  serverModuleFormat: "cjs",
};`,
				"package.json": `{
  "name": "remix-app",
  "private": true,
  "sideEffects": false,
  "scripts": {
    "build": "remix build",
    "dev": "remix dev",
    "start": "remix-serve build"
  },
  "dependencies": {
    "@remix-run/node": "^2.3.0",
    "@remix-run/react": "^2.3.0",
    "@remix-run/serve": "^2.3.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}`,
				"app/routes/_index.tsx": `export default function Index() {
  return <h1>Welcome to Remix</h1>;
}`,
				"app/root.tsx": `import { Links, LiveReload, Meta, Outlet, Scripts } from "@remix-run/react";
export default function App() {
  return (
    <html>
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}`,
				"pnpm-lock.yaml": "lockfileVersion: '6.0'",
			},
			expectedFramework: "Remix",
			expectedLanguage:  "JavaScript/TypeScript",
			expectedSignals:   []string{"remix.config", "package.json has @remix-run/react", "app/routes/ directory"},
			packageManager:    "pnpm",
			minConfidence:     0.9,
		},
		{
			name: "Remix minimal setup with npm",
			files: map[string]string{
				"remix.config.ts": `import type { AppConfig } from "@remix-run/dev";
export default {} as AppConfig;`,
				"package.json":        `{"dependencies": {"@remix-run/react": "^2.0.0"}}`,
				"app/routes/index.js": `export default function Index() { return <div>Home</div> }`,
			},
			expectedFramework: "Remix",
			expectedLanguage:  "JavaScript/TypeScript",
			expectedSignals:   []string{"remix.config", "package.json has @remix-run/react", "app/routes/ directory"},
			packageManager:    "npm",
			minConfidence:     0.9,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify package manager detection
			if detection.Meta["package_manager"] != tt.packageManager {
				t.Errorf("Expected package manager %s, got %s", tt.packageManager, detection.Meta["package_manager"])
			}

			// Verify build output
			if detection.Meta["build_output"] != "build/" {
				t.Errorf("Expected build_output 'build/', got %s", detection.Meta["build_output"])
			}
		})
	}
}

// Nuxt.js Detection Tests
func TestNuxtDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		packageManager    string
		minConfidence     float64
	}{
		{
			name: "Nuxt 3 with TypeScript config",
			files: map[string]string{
				"nuxt.config.ts": `export default defineNuxtConfig({
  devtools: { enabled: true },
  modules: ['@nuxtjs/tailwindcss'],
})`,
				"package.json": `{
  "name": "nuxt-app",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview"
  },
  "dependencies": {
    "nuxt": "^3.8.0"
  }
}`,
				"pages/index.vue": `<template>
  <div>
    <h1>Welcome to Nuxt 3</h1>
  </div>
</template>`,
				"pages/about.vue": `<template><div>About</div></template>`,
				"yarn.lock":       "# THIS IS AN AUTOGENERATED FILE",
			},
			expectedFramework: "Nuxt.js",
			expectedLanguage:  "JavaScript/TypeScript",
			expectedSignals:   []string{"nuxt.config", "package.json has nuxt", "pages/ directory or app.vue"},
			packageManager:    "yarn",
			minConfidence:     0.9,
		},
		{
			name: "Nuxt 3 with app.vue",
			files: map[string]string{
				"nuxt.config.js": `export default {
  ssr: true,
}`,
				"package.json": `{"dependencies": {"nuxt": "^3.0.0"}}`,
				"app.vue": `<template>
  <NuxtPage />
</template>`,
				"bun.lockb": "binary lock file",
			},
			expectedFramework: "Nuxt.js",
			expectedLanguage:  "JavaScript/TypeScript",
			expectedSignals:   []string{"nuxt.config", "package.json has nuxt", "pages/ directory or app.vue"},
			packageManager:    "bun",
			minConfidence:     0.9,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify package manager detection
			if detection.Meta["package_manager"] != tt.packageManager {
				t.Errorf("Expected package manager %s, got %s", tt.packageManager, detection.Meta["package_manager"])
			}

			// Verify build output
			if detection.Meta["build_output"] != ".output/" {
				t.Errorf("Expected build_output '.output/', got %s", detection.Meta["build_output"])
			}

			// Verify run command is Nuxt-specific
			if len(detection.RunPlan) > 0 && detection.RunPlan[0] != "node .output/server/index.mjs" {
				t.Errorf("Expected Nuxt 3 run command, got %s", detection.RunPlan[0])
			}
		})
	}
}

// Symfony Detection Tests
func TestSymfonyDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		minConfidence     float64
	}{
		{
			name: "Symfony 6 with symfony.lock and bin/console",
			files: map[string]string{
				"symfony.lock": `{
    "symfony/console": {
        "version": "v6.0.0"
    },
    "symfony/framework-bundle": {
        "version": "v6.0.0"
    }
}`,
				"bin/console": `#!/usr/bin/env php
<?php

use App\Kernel;
use Symfony\Bundle\FrameworkBundle\Console\Application;

require_once dirname(__DIR__).'/vendor/autoload.php';

$kernel = new Kernel($_SERVER['APP_ENV'] ?? 'dev', (bool) ($_SERVER['APP_DEBUG'] ?? true));
$application = new Application($kernel);
$application->run();`,
				"composer.json": `{
    "name": "symfony/skeleton",
    "type": "project",
    "require": {
        "symfony/console": "6.0.*",
        "symfony/framework-bundle": "6.0.*",
        "symfony/runtime": "6.0.*"
    }
}`,
				"config/bundles.php": `<?php
return [
    Symfony\Bundle\FrameworkBundle\FrameworkBundle::class => ['all' => true],
];`,
				"src/Controller/DefaultController.php": `<?php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class DefaultController extends AbstractController
{
    #[Route('/', name: 'app_default')]
    public function index(): Response
    {
        return $this->render('default/index.html.twig');
    }
}`,
			},
			expectedFramework: "Symfony",
			expectedLanguage:  "PHP",
			expectedSignals:   []string{"symfony.lock", "bin/console", "symfony in composer.json", "config/bundles.php"},
			minConfidence:     0.9,
		},
		{
			name: "Symfony minimal setup",
			files: map[string]string{
				"symfony.lock":  `{"symfony/console": {"version": "v5.4.0"}}`,
				"bin/console":   "#!/usr/bin/env php\n<?php\nrequire 'vendor/autoload.php';",
				"composer.json": `{"require": {"symfony/framework-bundle": "^5.4"}}`,
			},
			expectedFramework: "Symfony",
			expectedLanguage:  "PHP",
			expectedSignals:   []string{"symfony.lock", "bin/console", "symfony in composer.json"},
			minConfidence:     0.8,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify Symfony-specific build commands
			if len(detection.BuildPlan) > 0 {
				found := false
				for _, cmd := range detection.BuildPlan {
					if cmd == "composer install --no-dev --optimize-autoloader" {
						found = true
						break
					}
				}
				if !found {
					t.Error("Expected Symfony composer install command not found in build plan")
				}
			}
		})
	}
}

// Fastify Detection Tests
func TestFastifyDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		packageManager    string
		minConfidence     float64
	}{
		{
			name: "Fastify with TypeScript",
			files: map[string]string{
				"package.json": `{
  "name": "fastify-app",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "ts-node src/server.ts"
  },
  "dependencies": {
    "fastify": "^4.24.0",
    "@fastify/cors": "^8.4.0"
  }
}`,
				"server.js": `const fastify = require('fastify')({ logger: true });

fastify.get('/health', async (request, reply) => {
  return { status: 'ok' };
});

const start = async () => {
  try {
    await fastify.listen({ port: 3000 });
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start();`,
				"pnpm-lock.yaml": "lockfileVersion: '6.0'",
			},
			expectedFramework: "Fastify",
			expectedLanguage:  "JavaScript/TypeScript",
			expectedSignals:   []string{"package.json has fastify", "server.js or app.js"},
			packageManager:    "pnpm",
			minConfidence:     0.5,
		},
		{
			name: "Fastify minimal with app.js",
			files: map[string]string{
				"package.json": `{"dependencies": {"fastify": "^4.0.0"}}`,
				"app.js": `const fastify = require('fastify')();
fastify.get('/', async () => { return { hello: 'world' } });
fastify.listen({ port: 3000 });`,
			},
			expectedFramework: "Fastify",
			expectedLanguage:  "JavaScript/TypeScript",
			expectedSignals:   []string{"package.json has fastify", "server.js or app.js"},
			packageManager:    "npm",
			minConfidence:     0.5,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify package manager detection
			if detection.Meta["package_manager"] != tt.packageManager {
				t.Errorf("Expected package manager %s, got %s", tt.packageManager, detection.Meta["package_manager"])
			}
		})
	}
}

// Gin Detection Tests
func TestGinDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		minConfidence     float64
	}{
		{
			name: "Gin framework with go.mod and main.go",
			files: map[string]string{
				"go.mod": `module github.com/user/gin-app

go 1.21

require (
	github.com/gin-gonic/gin v1.9.1
	github.com/joho/godotenv v1.5.1
)`,
				"main.go": `package main

import (
	"log"
	"net/http"
	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "pong",
		})
	})

	if err := r.Run(":8080"); err != nil {
		log.Fatal(err)
	}
}`,
				"handlers/user.go": `package handlers

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func GetUser(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{"user": "john"})
}`,
			},
			expectedFramework: "Gin",
			expectedLanguage:  "Go",
			expectedSignals:   []string{"github.com/gin-gonic/gin in go.mod", "Gin import in .go files"},
			minConfidence:     0.6,
		},
		{
			name: "Gin minimal setup",
			files: map[string]string{
				"go.mod": `module myapp
go 1.21
require github.com/gin-gonic/gin v1.9.0`,
				"main.go": `package main
import "github.com/gin-gonic/gin"
func main() {
	r := gin.Default()
	r.Run()
}`,
			},
			expectedFramework: "Gin",
			expectedLanguage:  "Go",
			expectedSignals:   []string{"github.com/gin-gonic/gin in go.mod", "Gin import in .go files"},
			minConfidence:     0.6,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify framework meta
			if detection.Meta["framework"] != "gin" {
				t.Errorf("Expected framework meta 'gin', got %s", detection.Meta["framework"])
			}

			// Verify health check path is /ping for Gin
			if healthPath, ok := detection.Healthcheck["path"].(string); ok {
				if healthPath != "/ping" {
					t.Errorf("Expected health check path '/ping', got %s", healthPath)
				}
			}
		})
	}
}

// Echo Detection Tests
func TestEchoDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		minConfidence     float64
	}{
		{
			name: "Echo framework with go.mod and main.go",
			files: map[string]string{
				"go.mod": `module github.com/user/echo-app

go 1.21

require (
	github.com/labstack/echo/v4 v4.11.3
	github.com/labstack/gommon v0.4.0
)`,
				"main.go": `package main

import (
	"net/http"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func main() {
	e := echo.New()

	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	e.GET("/health", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"status": "ok"})
	})

	e.Logger.Fatal(e.Start(":8080"))
}`,
			},
			expectedFramework: "Echo",
			expectedLanguage:  "Go",
			expectedSignals:   []string{"github.com/labstack/echo in go.mod", "Echo import in .go files"},
			minConfidence:     0.6,
		},
		{
			name: "Echo minimal setup",
			files: map[string]string{
				"go.mod": `module myapp
go 1.21
require github.com/labstack/echo/v4 v4.11.0`,
				"main.go": `package main
import "github.com/labstack/echo/v4"
func main() {
	e := echo.New()
	e.Start(":8080")
}`,
			},
			expectedFramework: "Echo",
			expectedLanguage:  "Go",
			expectedSignals:   []string{"github.com/labstack/echo in go.mod", "Echo import in .go files"},
			minConfidence:     0.6,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify framework meta
			if detection.Meta["framework"] != "echo" {
				t.Errorf("Expected framework meta 'echo', got %s", detection.Meta["framework"])
			}
		})
	}
}

// Fiber Detection Tests
func TestFiberDetection(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		minConfidence     float64
	}{
		{
			name: "Fiber framework with go.mod and main.go",
			files: map[string]string{
				"go.mod": `module github.com/user/fiber-app

go 1.21

require (
	github.com/gofiber/fiber/v2 v2.51.0
	github.com/gofiber/template/html/v2 v2.0.5
)`,
				"main.go": `package main

import (
	"log"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/logger"
)

func main() {
	app := fiber.New()

	app.Use(logger.New())

	app.Get("/health", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{
			"status": "ok",
		})
	})

	log.Fatal(app.Listen(":8080"))
}`,
				"handlers/user.go": `package handlers

import "github.com/gofiber/fiber/v2"

func GetUser(c *fiber.Ctx) error {
	return c.SendString("User")
}`,
			},
			expectedFramework: "Fiber",
			expectedLanguage:  "Go",
			expectedSignals:   []string{"github.com/gofiber/fiber in go.mod", "Fiber import in .go files"},
			minConfidence:     0.6,
		},
		{
			name: "Fiber minimal setup",
			files: map[string]string{
				"go.mod": `module myapp
go 1.21
require github.com/gofiber/fiber/v2 v2.50.0`,
				"main.go": `package main
import "github.com/gofiber/fiber/v2"
func main() {
	app := fiber.New()
	app.Listen(":3000")
}`,
			},
			expectedFramework: "Fiber",
			expectedLanguage:  "Go",
			expectedSignals:   []string{"github.com/gofiber/fiber in go.mod", "Fiber import in .go files"},
			minConfidence:     0.6,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify framework meta
			if detection.Meta["framework"] != "fiber" {
				t.Errorf("Expected framework meta 'fiber', got %s", detection.Meta["framework"])
			}
		})
	}
}
