package detector_test

import (
	"testing"
)

// Laravel Detection Tests
func TestLaravelComprehensive(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedLanguage  string
		expectedSignals   []string
		minConfidence     float64
	}{
		{
			name: "Laravel with artisan and composer.lock",
			files: map[string]string{
				"artisan": `#!/usr/bin/env php
<?php

define('LARAVEL_START', microtime(true));

require __DIR__.'/vendor/autoload.php';`,
				"composer.lock": `{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies"
    ],
    "content-hash": "abc123",
    "packages": []
}`,
				"config/app.php": `<?php
return [
    'name' => env('APP_NAME', 'Laravel'),
    'env' => env('APP_ENV', 'production'),
];`,
				"app/Http/Controllers/Controller.php": `<?php
namespace App\Http\Controllers;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;`,
			},
			expectedFramework: "Laravel",
			expectedLanguage:  "PHP",
			expectedSignals:   []string{"artisan", "composer.lock", "config/app.php"},
			minConfidence:     0.9,
		},
		{
			name: "Laravel minimal setup",
			files: map[string]string{
				"artisan":      "#!/usr/bin/env php\n<?php\nrequire __DIR__.'/vendor/autoload.php';",
				"composer.lock": `{"packages": []}`,
			},
			expectedFramework: "Laravel",
			expectedLanguage:  "PHP",
			expectedSignals:   []string{"artisan", "composer.lock"},
			minConfidence:     0.8,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			if detection.Language != tt.expectedLanguage {
				t.Errorf("Expected language %s, got %s", tt.expectedLanguage, detection.Language)
			}

			if detection.Confidence < tt.minConfidence {
				t.Errorf("Expected confidence >= %f, got %f", tt.minConfidence, detection.Confidence)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Test build plan includes composer commands
			if len(detection.BuildPlan) == 0 {
				t.Error("Expected build plan to be non-empty")
			}
		})
	}
}

// Next.js Comprehensive Tests
func TestNextJSComprehensive(t *testing.T) {
	tests := []struct {
		name              string
		files             map[string]string
		expectedFramework string
		expectedSignals   []string
		packageManager    string
	}{
		{
			name: "Next.js 13+ with App Router and TypeScript",
			files: map[string]string{
				"next.config.js": `/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true,
  },
}
module.exports = nextConfig`,
				"package.json": `{
  "name": "nextjs-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.0.0",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/react": "^18",
    "@types/node": "^20"
  }
}`,
				"app/layout.tsx": `export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}`,
				"app/page.tsx":      `export default function Home() { return <main>Hello World</main> }`,
				"pnpm-lock.yaml":    "lockfileVersion: '6.0'\nspecifiers:\n  next: 14.0.0",
				"tsconfig.json":     `{"compilerOptions": {"target": "es5"}}`,
			},
			expectedFramework: "Next.js",
			expectedSignals:   []string{"next.config", "package.json has next", "pages/ or app/ folder"},
			packageManager:    "pnpm",
		},
		{
			name: "Next.js with Pages Router",
			files: map[string]string{
				"next.config.ts": `import type { NextConfig } from 'next'
const nextConfig: NextConfig = {}
export default nextConfig`,
				"package.json": `{
  "dependencies": {"next": "^13.0.0"},
  "scripts": {"dev": "next dev", "build": "next build"}
}`,
				"pages/index.js":    `export default function Home() { return <div>Home</div> }`,
				"pages/api/hello.js": `export default function handler(req, res) { res.json({hello: 'world'}) }`,
				"yarn.lock":         "# THIS IS AN AUTOGENERATED FILE",
			},
			expectedFramework: "Next.js",
			expectedSignals:   []string{"next.config", "package.json has next", "package.json scripts for next", "pages/ or app/ folder"},
			packageManager:    "yarn",
		},
		{
			name: "Next.js with Bun",
			files: map[string]string{
				"next.config.mjs": "export default {}",
				"package.json":    `{"dependencies": {"next": "latest"}}`,
				"app/globals.css":  "body { margin: 0; }",
				"app/page.jsx":     "export default function Page() { return <h1>Next.js</h1> }",
				"bun.lockb":        "binary lock file content",
			},
			expectedFramework: "Next.js",
			expectedSignals:   []string{"package.json has next", "pages/ or app/ folder"},
			packageManager:    "bun",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify correct package manager is detected in build plan
			if len(detection.BuildPlan) > 0 {
				firstCommand := detection.BuildPlan[0]
				switch tt.packageManager {
				case "pnpm":
					if firstCommand != "pnpm install" {
						t.Errorf("Expected pnpm install, got %s", firstCommand)
					}
				case "yarn":
					if firstCommand != "yarn install" {
						t.Errorf("Expected yarn install, got %s", firstCommand)
					}
				case "bun":
					if firstCommand != "bun install" {
						t.Errorf("Expected bun install, got %s", firstCommand)
					}
				default:
					if firstCommand != "npm install" {
						t.Errorf("Expected npm install, got %s", firstCommand)
					}
				}
			}
		})
	}
}

// Astro Comprehensive Tests
func TestAstroComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
	}{
		{
			name: "Astro with TypeScript and integrations",
			files: map[string]string{
				"astro.config.mjs": `import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';
import react from '@astrojs/react';

export default defineConfig({
  integrations: [tailwind(), react()],
});`,
				"package.json": `{
  "name": "astro-app",
  "scripts": {
    "dev": "astro dev",
    "build": "astro build",
    "preview": "astro preview"
  },
  "dependencies": {
    "astro": "^3.6.0",
    "@astrojs/tailwind": "^5.0.0"
  }
}`,
				"src/pages/index.astro": `---
const title = "Welcome to Astro";
---
<html>
  <head><title>{title}</title></head>
  <body><h1>{title}</h1></body>
</html>`,
				"src/components/Card.astro": `---
export interface Props {
  title: string;
}
const { title } = Astro.props;
---
<div class="card"><h2>{title}</h2></div>`,
				"public/favicon.svg": "<svg></svg>",
				"tsconfig.json":      `{"extends": "astro/tsconfigs/strict"}`,
			},
			expectedSignals: []string{"astro.config", "package.json has astro", "package.json scripts for astro", "src/ and public/ folders"},
		},
		{
			name: "Astro minimal setup",
			files: map[string]string{
				"astro.config.js":        "export default {}",
				"package.json":           `{"dependencies": {"astro": "^3.0.0"}}`,
				"src/pages/index.astro":  "---\n---\n<h1>Hello Astro</h1>",
				"public/robots.txt":      "User-agent: *\nDisallow:",
			},
			expectedSignals: []string{"astro.config", "package.json has astro", "src/ and public/ folders"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != "Astro" {
				t.Errorf("Expected Astro, got %s", detection.Framework)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}
		})
	}
}

// Vue.js Comprehensive Tests
func TestVueComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
		expectedFramework string
	}{
		{
			name: "Vue 3 with Vite",
			files: map[string]string{
				"vite.config.js": `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
})`,
				"package.json": `{
  "name": "vue-app",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.3.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.0.0",
    "vite": "^4.0.0"
  }
}`,
				"src/App.vue": `<template>
  <div id="app">
    <h1>{{ msg }}</h1>
  </div>
</template>

<script>
export default {
  data() {
    return { msg: 'Hello Vue!' }
  }
}
</script>`,
				"src/main.js":           `import { createApp } from 'vue'\nimport App from './App.vue'\ncreateApp(App).mount('#app')`,
				"index.html":            `<!DOCTYPE html><html><head><title>Vue App</title></head><body><div id="app"></div></body></html>`,
			},
			expectedFramework: "Vue.js",
			expectedSignals:   []string{"vue/vite config", "package.json has vue", ".vue files"},
		},
		{
			name: "Nuxt.js application",
			files: map[string]string{
				"nuxt.config.ts": `export default defineNuxtConfig({
  devtools: { enabled: true }
})`,
				"package.json": `{
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev"
  },
  "dependencies": {
    "nuxt": "^3.8.0",
    "vue": "^3.3.0"
  }
}`,
				"pages/index.vue": `<template>
  <div>
    <h1>Welcome to Nuxt!</h1>
  </div>
</template>`,
				"layouts/default.vue": `<template><div><slot /></div></template>`,
			},
			expectedFramework: "Nuxt.js",
			expectedSignals:   []string{"nuxt.config", "package.json has nuxt"},
		},
		{
			name: "Vue CLI project",
			files: map[string]string{
				"vue.config.js": `module.exports = {
  publicPath: process.env.NODE_ENV === 'production' ? '/my-app/' : '/'
}`,
				"package.json": `{
  "dependencies": {
    "@vue/cli": "^5.0.0",
    "vue": "^3.0.0"
  }
}`,
				"src/components/HelloWorld.vue": `<template><div>Hello</div></template>`,
				"src/views/Home.vue":             `<template><div>Home</div></template>`,
			},
			expectedFramework: "Vue.js",
			expectedSignals:   []string{"vue/vite config", "Vue CLI or Nuxt", ".vue files"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != tt.expectedFramework {
				t.Errorf("Expected framework %s, got %s", tt.expectedFramework, detection.Framework)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}
		})
	}
}

// Gatsby Comprehensive Tests
func TestGatsbyComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
	}{
		{
			name: "Gatsby with TypeScript and plugins",
			files: map[string]string{
				"gatsby-config.ts": `import type { GatsbyConfig } from "gatsby";

const config: GatsbyConfig = {
  siteMetadata: {
    title: "My Gatsby Site",
  },
  plugins: [
    "gatsby-plugin-image",
    "gatsby-plugin-sharp",
    "gatsby-transformer-sharp",
  ],
};

export default config;`,
				"package.json": `{
  "name": "gatsby-site",
  "scripts": {
    "develop": "gatsby develop",
    "build": "gatsby build",
    "serve": "gatsby serve"
  },
  "dependencies": {
    "gatsby": "^5.12.0",
    "react": "^18.0.0"
  }
}`,
				"src/pages/index.tsx": `import React from "react"
export default function IndexPage() {
  return <main><h1>Welcome to Gatsby!</h1></main>
}`,
				"src/pages/about.js":   `export default function About() { return <div>About</div> }`,
				"gatsby-browser.js":    `export const onClientEntry = () => { console.log("Gatsby loaded") }`,
			},
			expectedSignals: []string{"gatsby-config", "package.json has gatsby", "src/pages/ folder"},
		},
		{
			name: "Gatsby minimal setup",
			files: map[string]string{
				"gatsby-config.js": `module.exports = { siteMetadata: { title: "My Site" } }`,
				"package.json":     `{"dependencies": {"gatsby": "^5.0.0"}, "scripts": {"build": "gatsby build"}}`,
				"src/pages/index.js": `export default function Home() { return <h1>Home</h1> }`,
			},
			expectedSignals: []string{"gatsby-config", "package.json has gatsby", "package.json scripts for gatsby", "src/pages/ folder"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != "Gatsby" {
				t.Errorf("Expected Gatsby, got %s", detection.Framework)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}
		})
	}
}

// Svelte Comprehensive Tests
func TestSvelteComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
		variant         string
	}{
		{
			name: "SvelteKit with TypeScript",
			files: map[string]string{
				"svelte.config.js": `import adapter from '@sveltejs/adapter-auto';

const config = {
  kit: {
    adapter: adapter()
  }
};

export default config;`,
				"package.json": `{
  "name": "sveltekit-app",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@sveltejs/kit": "^1.27.0"
  },
  "devDependencies": {
    "svelte": "^4.0.0",
    "vite": "^4.0.0"
  }
}`,
				"src/routes/+page.svelte": `<script>
  let count = 0;
</script>

<h1>Welcome to SvelteKit</h1>
<p>Visit <a href="/about">about</a> to learn more.</p>`,
				"src/routes/+layout.svelte": `<main><slot /></main>`,
				"src/app.html":              `<!DOCTYPE html><html><head>%sveltekit.head%</head><body>%sveltekit.body%</body></html>`,
				"vite.config.js":            `import { sveltekit } from '@sveltejs/kit/vite'; export default { plugins: [sveltekit()] };`,
			},
			expectedSignals: []string{"svelte.config", "package.json has @sveltejs/kit", "src/routes/ folder (SvelteKit)"},
			variant:         "SvelteKit",
		},
		{
			name: "Regular Svelte app",
			files: map[string]string{
				"svelte.config.js": `export default { compilerOptions: { dev: true } }`,
				"package.json": `{
  "dependencies": {
    "svelte": "^4.0.0"
  },
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^15.0.0",
    "rollup": "^3.0.0"
  }
}`,
				"src/App.svelte": `<script>
  export let name;
</script>

<h1>Hello {name}!</h1>`,
				"src/main.js":     `import App from './App.svelte'; new App({ target: document.body });`,
				"rollup.config.js": `import svelte from 'rollup-plugin-svelte'; export default { plugins: [svelte()] };`,
			},
			expectedSignals: []string{"svelte.config", "package.json has svelte"},
			variant:         "Svelte",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != "Svelte" {
				t.Errorf("Expected Svelte, got %s", detection.Framework)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}
		})
	}
}

// Angular Comprehensive Tests
func TestAngularComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
	}{
		{
			name: "Angular with standalone components",
			files: map[string]string{
				"angular.json": `{
  "version": 1,
  "projects": {
    "my-app": {
      "projectType": "application",
      "schematics": {},
      "root": "",
      "sourceRoot": "src"
    }
  }
}`,
				"package.json": `{
  "name": "angular-app",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build"
  },
  "dependencies": {
    "@angular/animations": "^17.0.0",
    "@angular/common": "^17.0.0",
    "@angular/compiler": "^17.0.0",
    "@angular/core": "^17.0.0",
    "@angular/forms": "^17.0.0",
    "@angular/platform-browser": "^17.0.0"
  },
  "devDependencies": {
    "@angular/cli": "^17.0.0",
    "typescript": "~5.2.0"
  }
}`,
				"tsconfig.json": `{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "sourceMap": true,
    "declaration": false,
    "downlevelIteration": true,
    "experimentalDecorators": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "useDefineForClassFields": false,
    "lib": ["ES2022", "dom"]
  }
}`,
				"src/main.ts": `import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent).catch(err => console.error(err));`,
				"src/app/app.component.ts": `import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [],
  template: '<h1>Welcome to {{title}}!</h1>',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'angular-app';
}`,
			},
			expectedSignals: []string{"angular.json", "package.json has @angular/core", "TypeScript config with Angular structure"},
		},
		{
			name: "Angular minimal setup",
			files: map[string]string{
				"angular.json":  `{"version": 1, "projects": {}}`,
				"package.json":  `{"dependencies": {"@angular/core": "^16.0.0"}}`,
				"tsconfig.json": `{"compilerOptions": {"target": "es2020"}}`,
				"src/app/app.module.ts": `import { NgModule } from '@angular/core';
@NgModule({}) export class AppModule { }`,
				"src/main.ts": `import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';`,
			},
			expectedSignals: []string{"angular.json", "package.json has @angular/core", "TypeScript config with Angular structure"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != "Angular" {
				t.Errorf("Expected Angular, got %s", detection.Framework)
			}

			if detection.Language != "TypeScript" {
				t.Errorf("Expected TypeScript, got %s", detection.Language)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}
		})
	}
}

// Rails Comprehensive Tests
func TestRailsComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
	}{
		{
			name: "Rails 7 application",
			files: map[string]string{
				"bin/rails": `#!/usr/bin/env ruby
APP_PATH = File.expand_path("../config/application", __dir__)
require_relative "../config/boot"
require "rails/command"
require "rails/commands"`,
				"Gemfile.lock": `GEM
  remote: https://rubygems.org/
  specs:
    rails (7.0.0)
      actioncable (= 7.0.0)
      actionmailbox (= 7.0.0)
      actionmailer (= 7.0.0)
      actionpack (= 7.0.0)
      actiontext (= 7.0.0)
      actionview (= 7.0.0)
      activejob (= 7.0.0)
      activemodel (= 7.0.0)
      activerecord (= 7.0.0)
      activestorage (= 7.0.0)
      activesupport (= 7.0.0)
      bundler (>= 1.15.0)
      railties (= 7.0.0)

PLATFORMS
  ruby

DEPENDENCIES
  rails (~> 7.0.0)`,
				"config/application.rb": `require_relative "boot"

require "rails/all"

Bundler.require(*Rails.groups)

module MyRailsApp
  class Application < Rails::Application
    config.load_defaults 7.0
  end
end`,
				"config/routes.rb": `Rails.application.routes.draw do
  root "articles#index"
  resources :articles
end`,
				"app/controllers/application_controller.rb": `class ApplicationController < ActionController::Base
end`,
				"app/models/article.rb": `class Article < ApplicationRecord
  validates :title, presence: true
end`,
				"db/migrate/20231201000000_create_articles.rb": `class CreateArticles < ActiveRecord::Migration[7.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.timestamps
    end
  end
end`,
			},
			expectedSignals: []string{"bin/rails", "Gemfile.lock", "config/application.rb"},
		},
		{
			name: "Rails minimal setup",
			files: map[string]string{
				"bin/rails":             "#!/usr/bin/env ruby\nrequire 'rails/command'",
				"Gemfile.lock":          "GEM\n  remote: https://rubygems.org/\nPLATFORMS\n  ruby",
				"config/application.rb": "require 'rails/all'\nmodule App\n  class Application < Rails::Application\n  end\nend",
			},
			expectedSignals: []string{"bin/rails", "Gemfile.lock", "config/application.rb"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != "Rails" {
				t.Errorf("Expected Rails, got %s", detection.Framework)
			}

			if detection.Language != "Ruby" {
				t.Errorf("Expected Ruby, got %s", detection.Language)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify Rails-specific build commands
			if len(detection.BuildPlan) > 0 {
				found := false
				for _, cmd := range detection.BuildPlan {
					if cmd == "bundle install --deployment --without development test" {
						found = true
						break
					}
				}
				if !found {
					t.Error("Expected Rails bundle install command not found in build plan")
				}
			}
		})
	}
}

// Go Comprehensive Tests
func TestGoComprehensive(t *testing.T) {
	tests := []struct {
		name            string
		files           map[string]string
		expectedSignals []string
	}{
		{
			name: "Go microservice with standard library",
			files: map[string]string{
				"go.mod": `module github.com/user/myapp

go 1.21

require (
	github.com/joho/godotenv v1.4.0
)`,
				"main.go": `package main

import (
	"log"
	"net/http"
	"os"

	"github.com/joho/godotenv"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found")
	}

	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	})

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Server starting on port %s", port)
	http.ListenAndServe(":"+port, nil)
}`,
				"cmd/server/main.go": `package main

import "github.com/user/myapp"

func main() {
	myapp.Start()
}`,
				"internal/handlers/health.go": `package handlers

import "net/http"

func Health(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("OK"))
}`,
				"pkg/config/config.go": `package config

type Config struct {
	Port string
	DB   string
}`,
				"go.sum": `github.com/gin-gonic/gin v1.9.1 h1:abc123
github.com/gin-gonic/gin v1.9.1/go.mod h1:def456`,
			},
			expectedSignals: []string{"go.mod", "main.go/.go files"},
		},
		{
			name: "Go CLI application",
			files: map[string]string{
				"go.mod": `module github.com/user/cli-tool

go 1.21

require github.com/spf13/cobra v1.7.0`,
				"main.go": `package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "mytool",
	Short: "A brief description of your application",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("Hello from CLI!")
	},
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}`,
				"cmd/version.go": `package main

import (
	"fmt"
	"github.com/spf13/cobra"
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("v1.0.0")
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
}`,
			},
			expectedSignals: []string{"go.mod", "main.go/.go files"},
		},
		{
			name: "Go microservice with Docker",
			files: map[string]string{
				"go.mod": `module microservice

go 1.21

require (
	github.com/gorilla/mux v1.8.0
	github.com/prometheus/client_golang v1.17.0
)`,
				"main.go": `package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
)

func main() {
	r := mux.NewRouter()
	r.HandleFunc("/", homeHandler)
	log.Fatal(http.ListenAndServe(":8080", r))
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Hello World"))
}`,
				"Dockerfile": `FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN go build -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
CMD ["./main"]`,
				"handlers/user.go": `package handlers

import "net/http"

func GetUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
}`,
			},
			expectedSignals: []string{"go.mod", "main.go/.go files"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			projectPath := createTestProject(t, tt.files)
			detection := captureDetectFramework(t, projectPath)

			if detection.Framework != "Go" {
				t.Errorf("Expected Go, got %s", detection.Framework)
			}

			if detection.Language != "Go" {
				t.Errorf("Expected Go language, got %s", detection.Language)
			}

			for _, expectedSignal := range tt.expectedSignals {
				found := false
				for _, signal := range detection.Signals {
					if signal == expectedSignal {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected signal '%s' not found in %v", expectedSignal, detection.Signals)
				}
			}

			// Verify Go build command
			if len(detection.BuildPlan) > 0 {
				found := false
				for _, cmd := range detection.BuildPlan {
					if cmd == "go build -o app ." {
						found = true
						break
					}
				}
				if !found {
					t.Error("Expected 'go build -o app .' command not found in build plan")
				}
			}
		})
	}
}