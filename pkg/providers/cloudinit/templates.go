package cloudinit

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// UserData represents cloud-init user data configuration
type UserData struct {
	Username   string            `json:"username"`
	PublicKey  string            `json:"public_key"`
	AppName    string            `json:"app_name"`
	Packages   []string          `json:"packages"`
	Commands   []string          `json:"commands"`
	UFWRules   []string          `json:"ufw_rules"`
	Files      []CloudInitFile   `json:"files"`
	Metadata   map[string]string `json:"metadata"`
}

// CloudInitFile represents a file to be created via cloud-init
type CloudInitFile struct {
	Path        string      `json:"path"`
	Content     string      `json:"content"`
	Permissions string      `json:"permissions"`
	Owner       string      `json:"owner"`
	Encoding    string      `json:"encoding,omitempty"` // base64, gzip+base64
}

const defaultTemplate = `#cloud-config
# Generated by Lightfold CLI for {{.AppName}}
users:
  - name: {{.Username}}
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    ssh_authorized_keys:
      - {{.PublicKey}}

packages:
{{- range .Packages}}
  - {{.}}
{{- end}}

{{- if .Files}}
write_files:
{{- range .Files}}
  - path: {{.Path}}
    content: |
{{.Content | indent 6}}
    permissions: '{{.Permissions}}'
    owner: {{.Owner}}
{{- if .Encoding}}
    encoding: {{.Encoding}}
{{- end}}
{{- end}}
{{- end}}

runcmd:
  - mkdir -p /srv/{{.AppName}}/releases
  - mkdir -p /srv/{{.AppName}}/shared/logs
  - mkdir -p /srv/{{.AppName}}/shared/uploads
  - mkdir -p /srv/{{.AppName}}/shared/config
  - mkdir -p /srv/{{.AppName}}/shared/env
  - chown -R {{.Username}}:{{.Username}} /srv/{{.AppName}}

{{- range .UFWRules}}
  - {{.}}
{{- end}}
  - ufw --force enable

  # Additional setup commands
{{- range .Commands}}
  - {{.}}
{{- end}}

  - touch /var/lib/cloud/instance/lightfold-setup-complete

final_message: "Lightfold server setup completed successfully!"
`

// GenerateUserData generates cloud-init user data for a web application deployment
func GenerateUserData(config UserData) (string, error) {
	// Set defaults if not provided
	if config.Username == "" {
		config.Username = "deploy"
	}

	if config.AppName == "" {
		config.AppName = "app"
	}

	if len(config.Packages) == 0 {
		config.Packages = getDefaultPackages()
	}

	if len(config.UFWRules) == 0 {
		config.UFWRules = getDefaultUFWRules()
	}

	tmpl := template.New("cloudinit").Funcs(template.FuncMap{
		"indent": indentText,
	})

	// Parse the template
	tmpl, err := tmpl.Parse(defaultTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse cloud-init template: %w", err)
	}

	// Execute the template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return "", fmt.Errorf("failed to execute cloud-init template: %w", err)
	}

	return buf.String(), nil
}

// GenerateWebAppUserData creates cloud-init configuration for web applications
func GenerateWebAppUserData(username, publicKey, appName string) (string, error) {
	config := UserData{
		Username:  username,
		PublicKey: publicKey,
		AppName:   appName,
		Packages:  getDefaultPackages(),
		UFWRules:  getDefaultUFWRules(),
		Commands:  getDefaultCommands(username, appName),
	}

	return GenerateUserData(config)
}

// GenerateMinimalUserData creates minimal cloud-init configuration for basic setup
func GenerateMinimalUserData(username, publicKey string) (string, error) {
	config := UserData{
		Username:  username,
		PublicKey: publicKey,
		AppName:   "app",
		Packages:  getMinimalPackages(),
		UFWRules:  getBasicUFWRules(),
		Commands:  []string{},
	}

	return GenerateUserData(config)
}

func getDefaultPackages() []string {
	return []string{
		"curl",
		"wget",
		"git",
		"unzip",
		"nginx",
		"docker.io",
		"docker-compose",
		"certbot",
		"python3-certbot-nginx",
		"ufw",
		"fail2ban",
		"htop",
		"vim",
		"tmux",
	}
}

// getMinimalPackages returns a minimal package list
func getMinimalPackages() []string {
	return []string{
		"curl",
		"wget",
		"git",
		"nginx",
		"ufw",
		"vim",
	}
}

func getDefaultUFWRules() []string {
	return []string{
		"ufw allow 22/tcp",   // SSH
		"ufw allow 80/tcp",   // HTTP
		"ufw allow 443/tcp",  // HTTPS
	}
}

func getBasicUFWRules() []string {
	return []string{
		"ufw allow 22/tcp",   // SSH
		"ufw allow 80/tcp",   // HTTP
	}
}

func getDefaultCommands(username, appName string) []string {
	return []string{
		"systemctl enable nginx",
		"systemctl start nginx",
		"systemctl enable docker",
		"systemctl start docker",
		fmt.Sprintf("usermod -aG docker %s", username),
		"systemctl enable fail2ban",
		"systemctl start fail2ban",
		fmt.Sprintf("echo 'export PATH=\"$PATH:/srv/%s/current\"' >> /home/%s/.bashrc", appName, username),
	}
}

func indentText(indent int, text string) string {
	if text == "" {
		return ""
	}

	lines := strings.Split(text, "\n")
	indentStr := strings.Repeat(" ", indent)

	var result []string
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			result = append(result, indentStr+line)
		} else {
			result = append(result, "")
		}
	}

	return strings.Join(result, "\n")
}

// ValidateUserData performs basic validation on cloud-init user data
func ValidateUserData(config UserData) error {
	if config.Username == "" {
		return fmt.Errorf("username is required")
	}

	if config.PublicKey == "" {
		return fmt.Errorf("public SSH key is required")
	}

	// Basic SSH public key format validation
	if !strings.Contains(config.PublicKey, " ") {
		return fmt.Errorf("invalid SSH public key format")
	}

	// Validate app name (basic filesystem-safe validation)
	if config.AppName != "" {
		if strings.ContainsAny(config.AppName, "/\\:*?\"<>|") {
			return fmt.Errorf("app name contains invalid characters")
		}
	}

	return nil
}

// AddNginxConfig adds Nginx configuration for a web application
func AddNginxConfig(config *UserData, domain, appPort string) {
	nginxConfig := fmt.Sprintf(`server {
    listen 80;
    server_name %s;

    location / {
        proxy_pass http://localhost:%s;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}`, domain, appPort)

	file := CloudInitFile{
		Path:        "/etc/nginx/sites-available/" + config.AppName,
		Content:     nginxConfig,
		Permissions: "0644",
		Owner:       "root:root",
	}

	config.Files = append(config.Files, file)

	// Add command to enable the site
	config.Commands = append(config.Commands,
		fmt.Sprintf("ln -sf /etc/nginx/sites-available/%s /etc/nginx/sites-enabled/", config.AppName),
		"nginx -t && systemctl reload nginx",
	)
}

// AddSystemdService adds a systemd service file for the application
func AddSystemdService(config *UserData, serviceName, execStart, workingDir string) {
	serviceConfig := fmt.Sprintf(`[Unit]
Description=%s service
After=network.target

[Service]
Type=simple
User=%s
WorkingDirectory=%s
ExecStart=%s
Restart=always
RestartSec=5
Environment=NODE_ENV=production

[Install]
WantedBy=multi-user.target`, serviceName, config.Username, workingDir, execStart)

	file := CloudInitFile{
		Path:        "/etc/systemd/system/" + serviceName + ".service",
		Content:     serviceConfig,
		Permissions: "0644",
		Owner:       "root:root",
	}

	config.Files = append(config.Files, file)

	// Add commands to enable and start the service
	config.Commands = append(config.Commands,
		"systemctl daemon-reload",
		fmt.Sprintf("systemctl enable %s", serviceName),
	)
}