package flyio

import (
	"bytes"
	"fmt"
	"lightfold/pkg/detector"
	"text/template"
)

// FlyTomlConfig contains parameters for generating fly.toml
type FlyTomlConfig struct {
	AppName       string
	PrimaryRegion string
	InternalPort  int
	HealthPath    string
	HealthTimeout int
	EnvVars       map[string]string
	MemoryMB      int
	CPUs          int
}

const flyTomlTemplate = `# fly.toml - Generated by Lightfold
app = "{{.AppName}}"
primary_region = "{{.PrimaryRegion}}"

[build]

[env]
{{- range $key, $value := .EnvVars}}
  {{$key}} = "{{$value}}"
{{- end}}

[http_service]
  internal_port = {{.InternalPort}}
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]

  [[http_service.checks]]
    interval = "15s"
    timeout = "{{.HealthTimeout}}s"
    grace_period = "10s"
    method = "GET"
    path = "{{.HealthPath}}"
    protocol = "http"

[[vm]]
  memory = "{{.MemoryMB}}mb"
  cpu_kind = "shared"
  cpus = {{.CPUs}}
`

// GenerateFlyToml generates a fly.toml configuration from detector results
func GenerateFlyToml(detection *detector.Detection, appName, region, machineSize string) (string, error) {
	// Determine internal port from detection or use default (8080 for most frameworks)
	internalPort := 8080

	// Determine health check path
	healthPath := "/"
	healthTimeout := 30
	if detection.Healthcheck != nil {
		if path, ok := detection.Healthcheck["path"].(string); ok {
			healthPath = path
		}
		if timeout, ok := detection.Healthcheck["timeout_seconds"].(int); ok {
			healthTimeout = timeout
		}
	}

	// Parse machine size to get memory and CPUs
	memoryMB, cpus := parseMachineSize(machineSize)

	// Build env vars (non-secret ones can go in fly.toml)
	envVars := map[string]string{
		"PORT": fmt.Sprintf("%d", internalPort),
	}

	config := FlyTomlConfig{
		AppName:       appName,
		PrimaryRegion: region,
		InternalPort:  internalPort,
		HealthPath:    healthPath,
		HealthTimeout: healthTimeout,
		EnvVars:       envVars,
		MemoryMB:      memoryMB,
		CPUs:          cpus,
	}

	tmpl, err := template.New("flytoml").Parse(flyTomlTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse fly.toml template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return "", fmt.Errorf("failed to generate fly.toml: %w", err)
	}

	return buf.String(), nil
}

// parseMachineSize converts fly.io machine size ID to memory (MB) and CPU count
func parseMachineSize(sizeID string) (memoryMB int, cpus int) {
	// Map of fly.io machine sizes to their specs
	// Format: "shared-cpu-1x" -> 256MB RAM, 1 vCPU
	sizeMap := map[string]struct{ memory, cpus int }{
		"shared-cpu-1x":  {256, 1},
		"shared-cpu-2x":  {512, 1},
		"shared-cpu-4x":  {1024, 2},
		"shared-cpu-8x":  {2048, 4},
		"performance-1x": {2048, 1},
		"performance-2x": {4096, 2},
		"performance-4x": {8192, 4},
		"performance-8x": {16384, 8},
	}

	if specs, exists := sizeMap[sizeID]; exists {
		return specs.memory, specs.cpus
	}

	// Default to smallest size if unknown
	return 256, 1
}
